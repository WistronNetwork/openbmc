From af7fa10e42a244445dd27a7629e879817dc36bbc Mon Sep 17 00:00:00 2001
From: jarvis_wc_chen <jarvis_wc_chen@wistron.com>
Date: Thu, 14 Sep 2023 16:22:14 +0800
Subject: [PATCH] hwmon-pmbus-xdpe12284.c-Add-a-multiple-for-POUT

---
 drivers/hwmon/pmbus/xdpe12284.c | 70 +++++++++++++++++++++++++++++++++
 1 file changed, 70 insertions(+)

diff --git a/drivers/hwmon/pmbus/xdpe12284.c b/drivers/hwmon/pmbus/xdpe12284.c
index 0169246747e3..6373007088d3 100644
--- a/drivers/hwmon/pmbus/xdpe12284.c
+++ b/drivers/hwmon/pmbus/xdpe12284.c
@@ -22,11 +22,15 @@
 enum {
 	XDPE122_VOUT3,
 	XDPE122_VOUT4,
+	XDPE122_POUT3,
+	XDPE122_POUT4,
 };
 
 static const char * const labels[] = {
 	[XDPE122_VOUT3]	=	"vout3",
 	[XDPE122_VOUT4]	=	"vout4",
+	[XDPE122_POUT3]	=	"pout3",
+	[XDPE122_POUT4]	=	"pout4",
 };
 
 static u32 vout_loop_a_multiple = 0;
@@ -184,6 +188,64 @@ static ssize_t xdpe122_vout_value_show(struct device *dev,
 		return -EINVAL;
 }
 
+static ssize_t xdpe122_pout_value_show(struct device *dev,
+					struct device_attribute *devattr,
+					char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev->parent);
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	const struct pmbus_driver_info *info = pmbus_get_driver_info(client);
+
+	u32 val;
+	int ret;
+	s16 exponent;
+	s32 mantissa;
+
+	if (of_property_read_u32(client->dev.of_node,
+				 "vout_loop_a_multiple", &vout_loop_a_multiple))
+		vout_loop_a_multiple = 1000; /* Default 1000 if not set via DT */
+
+	if (vout_loop_a_multiple == 0)
+		return -EINVAL;
+
+	if (of_property_read_u32(client->dev.of_node,
+				 "vout_loop_b_multiple", &vout_loop_b_multiple))
+		vout_loop_b_multiple = 1000; /* Default 1000 if not set via DT */
+
+	if (vout_loop_b_multiple == 0)
+		return -EINVAL;
+
+	ret = pmbus_read_word_data(client, attr->index, 0xff, PMBUS_READ_POUT);
+	if (ret < 0)
+		return ret;
+	
+	val = (u32) ret;
+
+	/* Convert register value to LINEAR11 data. */
+	exponent = ((s16)ret) >> 11;
+	mantissa = ((s16)((ret & GENMASK(10, 0)) << 5)) >> 5;
+
+	/*If there is a scale of voltage in device tree, 
+	  we need to multiply a scale in power, too */
+	val = (u32) mantissa * 1000L;
+	if (exponent >= 0)
+		val <<= exponent;
+	else
+		val >>= -exponent;
+	
+	if (attr->index == 0) // PAGE 0
+		val = val * vout_loop_a_multiple;
+	else if (attr->index == 1) // PAGE 1
+		val = val * vout_loop_b_multiple;
+	else
+		val = val * 1000;
+
+	if (attr->index == 0 || attr->index == 1) // PAGE 0 or PAGE 1
+		return sprintf(buf, "%lu\n", val);
+	else
+		return -EINVAL;
+}
+
 static ssize_t label_show(struct device *dev,
                           struct device_attribute *devattr, char *buf)
 {
@@ -194,12 +256,20 @@ static SENSOR_DEVICE_ATTR_RO(in5_input, xdpe122_vout_value, 0);  //PAGE 0
 static SENSOR_DEVICE_ATTR_RO(in5_label, label, XDPE122_VOUT3);
 static SENSOR_DEVICE_ATTR_RO(in6_input, xdpe122_vout_value, 1);  //PAGE 1
 static SENSOR_DEVICE_ATTR_RO(in6_label, label, XDPE122_VOUT4);
+static SENSOR_DEVICE_ATTR_RO(power5_input, xdpe122_pout_value, 0);  //PAGE 0
+static SENSOR_DEVICE_ATTR_RO(power5_label, label, XDPE122_POUT3);
+static SENSOR_DEVICE_ATTR_RO(power6_input, xdpe122_pout_value, 1);  //PAGE 1
+static SENSOR_DEVICE_ATTR_RO(power6_label, label, XDPE122_POUT4);
 
 static struct attribute *xdpe122_value_attrs[] = {
 	&sensor_dev_attr_in5_input.dev_attr.attr,
 	&sensor_dev_attr_in5_label.dev_attr.attr,
 	&sensor_dev_attr_in6_input.dev_attr.attr,
 	&sensor_dev_attr_in6_label.dev_attr.attr,
+	&sensor_dev_attr_power5_input.dev_attr.attr,
+	&sensor_dev_attr_power5_label.dev_attr.attr,
+	&sensor_dev_attr_power6_input.dev_attr.attr,
+	&sensor_dev_attr_power6_label.dev_attr.attr,
 	NULL,
 };
 
-- 
2.25.1

