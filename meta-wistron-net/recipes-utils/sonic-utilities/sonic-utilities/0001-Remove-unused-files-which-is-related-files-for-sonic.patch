From abbcfd16f8f28fae30d05d913bd491bbbf70d42e Mon Sep 17 00:00:00 2001
From: Neal_Chen <neal_chen@wistron.com>
Date: Tue, 6 Jun 2023 13:40:16 +0800
Subject: [PATCH 1/3] Remove unused files which is related files for sonic

Signed-off-by: Neal_Chen <neal_chen@wistron.com>
---
 utilities_common/auto_techsupport_helper.py | 337 ----------
 utilities_common/bgp_util.py                | 354 ----------
 utilities_common/chassis.py                 |  18 -
 utilities_common/cli.py                     | 706 --------------------
 utilities_common/constants.py               |  12 -
 utilities_common/db.py                      |  42 --
 utilities_common/dhcp_relay_util.py         |  20 -
 utilities_common/general.py                 |  44 --
 utilities_common/helper.py                  |  66 --
 utilities_common/intf_filter.py             |  55 --
 utilities_common/multi_asic.py              | 191 ------
 utilities_common/netstat.py                 | 120 ----
 utilities_common/platform_sfputil_helper.py | 147 ----
 utilities_common/util_base.py               |  91 ---
 14 files changed, 2203 deletions(-)
 delete mode 100644 utilities_common/auto_techsupport_helper.py
 delete mode 100644 utilities_common/bgp_util.py
 delete mode 100644 utilities_common/chassis.py
 delete mode 100644 utilities_common/cli.py
 delete mode 100644 utilities_common/constants.py
 delete mode 100644 utilities_common/db.py
 delete mode 100644 utilities_common/dhcp_relay_util.py
 delete mode 100644 utilities_common/general.py
 delete mode 100644 utilities_common/helper.py
 delete mode 100755 utilities_common/intf_filter.py
 delete mode 100644 utilities_common/multi_asic.py
 delete mode 100755 utilities_common/netstat.py
 delete mode 100644 utilities_common/platform_sfputil_helper.py
 delete mode 100644 utilities_common/util_base.py

diff --git a/utilities_common/auto_techsupport_helper.py b/utilities_common/auto_techsupport_helper.py
deleted file mode 100644
index 30c99ce0..00000000
--- a/utilities_common/auto_techsupport_helper.py
+++ /dev/null
@@ -1,337 +0,0 @@
-import os
-import re
-import glob
-import time
-import subprocess
-import shutil
-import math
-import syslog
-from os.path import basename, splitext
-
-__all__ = [  # Contants
-            "CORE_DUMP_DIR", "CORE_DUMP_PTRN", "TS_DIR", "TS_PTRN",
-            "CFG_DB", "AUTO_TS", "CFG_STATE", "CFG_MAX_TS", "COOLOFF",
-            "CFG_CORE_USAGE", "CFG_SINCE", "FEATURE", "STATE_DB",
-            "TS_MAP", "CORE_DUMP", "TIMESTAMP", "CONTAINER", "TIME_BUF",
-            "SINCE_DEFAULT", "TS_PTRN_GLOB", "EXT_LOCKFAIL", "EXT_RETRY",
-            "EXT_SUCCESS", "MAX_RETRY_LIMIT", "EVENT_TYPE", "EVENT_TYPE_CORE",
-            "EVENT_TYPE_MEMORY"
-        ] + [  # Methods
-            "verify_recent_file_creation",
-            "get_ts_dumps",
-            "strip_ts_ext",
-            "get_stats",
-            "pretty_size",
-            "cleanup_process",
-            "subprocess_exec",
-            "trim_masic_suffix",
-            "invoke_ts_command_rate_limited",
-        ]
-
-
-# MISC
-CORE_DUMP_DIR = "/var/core"
-CORE_DUMP_PTRN = "*.core.gz"
-
-TS_DIR = "/var/dump"
-TS_ROOT = "sonic_dump_*"
-TS_PTRN = "sonic_dump_.*tar.*" # Regex Exp
-TS_PTRN_GLOB = "sonic_dump_*tar*" # Glob Exp
-
-# DBs identifiers
-CFG_DB = "CONFIG_DB"
-STATE_DB = "STATE_DB"
-
-# AUTO_TECHSUPPORT|GLOBAL table attributes
-AUTO_TS = "AUTO_TECHSUPPORT|GLOBAL"
-CFG_STATE = "state"
-CFG_MAX_TS = "max_techsupport_limit"
-COOLOFF = "rate_limit_interval"
-CFG_CORE_USAGE = "max_core_limit"
-CFG_SINCE = "since"
-
-# AUTO_TECHSUPPORT_FEATURE Table
-FEATURE = "AUTO_TECHSUPPORT_FEATURE|{}"
-
-# State DB Attributes
-STATE_DB = "STATE_DB"
-
-# AUTO_TECHSUPPORT_DUMP_INFO table info
-TS_MAP = "AUTO_TECHSUPPORT_DUMP_INFO"
-CORE_DUMP = "core_dump"
-TIMESTAMP = "timestamp"
-CONTAINER = "container_name"
-EVENT_TYPE = "event_type"
-
-EVENT_TYPE_CORE = "core"
-EVENT_TYPE_MEMORY = "memory"
-
-TIME_BUF = 20
-SINCE_DEFAULT = "2 days ago"
-TS_GLOBAL_TIMEOUT = "60"
-
-# Explicity Pass this to the subprocess invoking techsupport
-ENV_VAR = os.environ
-if ('CROSS_BUILD_ENVIRON' not in ENV_VAR) or (ENV_VAR['CROSS_BUILD_ENVIRON'] != 'y'):
-	# Add native system directories to PATH variable only if it is not cross-compilation build 
-	PATH_PREV = ENV_VAR["PATH"] if "PATH" in ENV_VAR else ""
-	ENV_VAR["PATH"] = "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:" + PATH_PREV
-
-# Techsupport Exit Codes
-EXT_LOCKFAIL = 2
-EXT_RETRY = 4
-EXT_SUCCESS = 0
-MAX_RETRY_LIMIT = 2
-
-# Helper methods
-def subprocess_exec(cmd, env=None):
-    output = subprocess.run(
-        cmd,
-        capture_output=True,
-        text=True,
-        env=env
-    )
-    return output.returncode, output.stdout, output.stderr
-
-
-def strip_ts_ext(ts_path):
-    """ Return the basename and strip the techsupport dump of any extensions """
-    base_name = basename(ts_path)
-    name, _ = splitext(splitext(base_name)[0])  # *.tar.gz
-    return name
-
-
-def get_ts_dumps(full_path=False):
-    """
-    Get the list of TS dumps in the TS_DIR, sorted by the creation time
-    """
-    curr_list = glob.glob(os.path.join(TS_DIR, TS_ROOT))
-    curr_list.sort(key=os.path.getmtime)
-    if full_path:
-        return curr_list
-    return [os.path.basename(name) for name in curr_list]
-
-
-def verify_recent_file_creation(file_path, in_last_sec=TIME_BUF):
-    """ Verify if the file exists and is created within the last TIME_BUF sec """
-    curr = time.time()
-    try:
-        was_created_on = os.path.getmtime(file_path)
-    except Exception:
-        return False
-    if curr - was_created_on < in_last_sec:
-        return True
-    else:
-        return False
-
-
-def get_stats(ptrn, collect_stats=True):
-    """
-    Returns the size of the files (matched by the ptrn) occupied.
-    Also returns the list of files Sorted by the Descending order of creation time & size
-    """
-    files = glob.glob(ptrn)
-    file_stats = []
-    total_size = 0
-    for file in files:
-        file_size = os.path.getsize(file)
-        if collect_stats:
-            file_stats.append((os.path.getmtime(file), file_size, file))
-        total_size += file_size
-    if collect_stats:
-        # Sort by the Descending order of file_creation_time, size_of_file
-        file_stats = sorted(file_stats, key=lambda sub: (-sub[0], sub[1], sub[2]))
-    return (file_stats, total_size)
-
-
-def pretty_size(bytes):
-    """Get human-readable file sizes"""
-    UNITS_MAPPING = [
-        (1 << 50, ' PB'),
-        (1 << 40, ' TB'),
-        (1 << 30, ' GB'),
-        (1 << 20, ' MB'),
-        (1 << 10, ' KB'),
-        (1, (' byte', ' bytes')),
-    ]
-    for factor, suffix in UNITS_MAPPING:
-        if bytes >= factor:
-            break
-    amount = int(bytes / factor)
-
-    if isinstance(suffix, tuple):
-        singular, multiple = suffix
-        if amount == 1:
-            suffix = singular
-        else:
-            suffix = multiple
-    return str(amount) + suffix
-
-
-def cleanup_process(limit, file_ptrn, dir):
-    """Deletes the oldest files incrementally until the size is under limit"""
-    if not(0 < limit and limit < 100):
-        syslog.syslog(syslog.LOG_ERR, "core_usage_limit can only be between 1 and 100, whereas the configured value is: {}".format(limit))
-        return
-
-    fs_stats, curr_size = get_stats(os.path.join(dir, file_ptrn))
-    disk_stats = shutil.disk_usage(dir)
-    max_limit_bytes = math.floor((limit * disk_stats.total / 100))
-
-    if curr_size <= max_limit_bytes:
-        return
-
-    num_bytes_to_del = curr_size - max_limit_bytes
-    num_deleted = 0
-    removed_files = []
-    # Preserve the latest file created
-    while num_deleted < num_bytes_to_del and len(fs_stats) > 1:
-        stat = fs_stats.pop()
-        try:
-            os.remove(stat[2])
-            removed_files.append(stat[2])
-        except OSError as error:
-            continue
-        num_deleted += stat[1]
-    syslog.syslog(syslog.LOG_INFO, "{} deleted from {}".format(pretty_size(num_deleted), dir))
-    return removed_files
-
-
-def trim_masic_suffix(container_name):
-    """ Trim any masic suffix i.e swss0 -> swss """
-    arr = list(container_name)
-    index = len(arr) - 1
-    while index >= 0:
-        if arr[-1].isdigit():
-            arr.pop()
-        else:
-            break
-        index = index - 1
-    return "".join(arr)
-
-def get_since_arg(db):
-    """Get since configuration from AUTO_TECHSUPPORT table or default value"""
-    since_cfg = db.get(CFG_DB, AUTO_TS, CFG_SINCE)
-    if not since_cfg:
-        return SINCE_DEFAULT
-    rc, _, stderr = subprocess_exec(["date", "--date={}".format(since_cfg)], env=ENV_VAR)
-    if rc == 0:
-        return since_cfg
-    return SINCE_DEFAULT
-
-
-def parse_ts_dump_name(ts_stdout):
-    """ Figure out the ts_dump name from the techsupport stdout """
-    matches = re.findall(TS_PTRN, ts_stdout)
-    if matches:
-        return matches[-1]
-    syslog.syslog(syslog.LOG_ERR, "stdout of the 'show techsupport' cmd doesn't have the dump name")
-    return ""
-
-
-def invoke_ts_cmd(db, num_retry=0):
-    """Invoke techsupport generation command"""
-    since_cfg = get_since_arg(db)
-    cmd_opts = ["show", "techsupport", "--silent", "--global-timeout", TS_GLOBAL_TIMEOUT, "--since", since_cfg]
-    cmd  = " ".join(cmd_opts)
-    rc, stdout, stderr = subprocess_exec(cmd_opts, env=ENV_VAR)
-    new_dump = ""
-    if rc == EXT_LOCKFAIL:
-        syslog.syslog(syslog.LOG_NOTICE, "Another instance of techsupport running, aborting this. stderr: {}".format(stderr))
-    elif rc == EXT_RETRY:
-        if num_retry <= MAX_RETRY_LIMIT:
-            return invoke_ts_cmd(db, num_retry+1)
-        else:
-            syslog.syslog(syslog.LOG_ERR, "MAX_RETRY_LIMIT for show techsupport invocation exceeded, stderr: {}".format(stderr))
-    elif rc != EXT_SUCCESS:
-        syslog.syslog(syslog.LOG_ERR, "show techsupport failed with exit code {}, stderr: {}".format(rc, stderr))
-    else: # EXT_SUCCESS
-        new_dump = parse_ts_dump_name(stdout) # Parse the dump name
-        if not new_dump:
-            syslog.syslog(syslog.LOG_ERR, "{} was run, but no techsupport dump is found".format(cmd))
-        else:
-            syslog.syslog(syslog.LOG_INFO, "{} is successful, {} is created".format(cmd, new_dump))
-    return new_dump
-
-
-def get_ts_map(db):
-    """Create ts_dump & creation_time map"""
-    ts_map = {}
-    ts_keys = db.keys(STATE_DB, TS_MAP+"*")
-    if not ts_keys:
-        return ts_map
-    for ts_key in ts_keys:
-        data = db.get_all(STATE_DB, ts_key)
-        if not data:
-            continue
-        container_name = data.get(CONTAINER, "")
-        creation_time = data.get(TIMESTAMP, "")
-        try:
-            creation_time = int(creation_time)
-        except Exception:
-            continue  # if the creation time is invalid, skip the entry
-        ts_dump = ts_key.split("|")[-1]
-        if container_name not in ts_map:
-            ts_map[container_name] = []
-        ts_map[container_name].append((int(creation_time), ts_dump))
-    for container_name in ts_map:
-        ts_map[container_name].sort()
-    return ts_map
-
-
-def verify_rate_limit_intervals(db, global_cooloff, container_cooloff, container):
-    """Verify both the global and per-proc rate_limit_intervals have passed"""
-    curr_ts_list = get_ts_dumps(True)
-    if global_cooloff and curr_ts_list:
-        last_ts_dump_creation = os.path.getmtime(curr_ts_list[-1])
-        if time.time() - last_ts_dump_creation < global_cooloff:
-            msg = "Global rate_limit_interval period has not passed. Techsupport Invocation is skipped"
-            syslog.syslog(msg)
-            return False
-
-    ts_map = get_ts_map(db)
-    if container_cooloff and container in ts_map:
-        last_creation_time = ts_map[container][0][0]
-        if time.time() - last_creation_time < container_cooloff:
-            msg = "Per Container rate_limit_interval for {} has not passed. Techsupport Invocation is skipped"
-            syslog.syslog(msg.format(container))
-            return False
-    return True
-
-
-def write_to_state_db(db, timestamp, ts_dump, event_type, event_data, container=None):
-    name = strip_ts_ext(ts_dump)
-    key = TS_MAP + "|" + name
-    db.set(STATE_DB, key, TIMESTAMP, str(timestamp))
-    db.set(STATE_DB, key, EVENT_TYPE, event_type)
-    for event_data_key, event_data_value in event_data.items():
-        db.set(STATE_DB, key, event_data_key, event_data_value)
-    if container:
-        db.set(STATE_DB, key, CONTAINER, container)
-
-
-def invoke_ts_command_rate_limited(db, event_type, event_data, container=None):
-    """Invoke techsupport generation command accounting the rate limit"""
-    global_cooloff = db.get(CFG_DB, AUTO_TS, COOLOFF)
-    if container:
-        container_cooloff = db.get(
-            CFG_DB, FEATURE.format(container), COOLOFF
-        )
-    else:
-        container_cooloff = 0.0
-
-    try:
-        global_cooloff = float(global_cooloff)
-    except ValueError:
-        global_cooloff = 0.0
-
-    try:
-        container_cooloff = float(container_cooloff)
-    except ValueError:
-        container_cooloff = 0.0
-
-    cooloff_passed = verify_rate_limit_intervals(db, global_cooloff, container_cooloff, container)
-    if cooloff_passed:
-        new_file = invoke_ts_cmd(db)
-        if new_file:
-            write_to_state_db(db, int(time.time()), new_file, event_type, event_data, container)
diff --git a/utilities_common/bgp_util.py b/utilities_common/bgp_util.py
deleted file mode 100644
index 3897d4a1..00000000
--- a/utilities_common/bgp_util.py
+++ /dev/null
@@ -1,354 +0,0 @@
-import ipaddress
-import json
-import re
-import sys
-
-import click
-import utilities_common.cli as clicommon
-import utilities_common.multi_asic as multi_asic_util
-from natsort import natsorted
-from sonic_py_common import multi_asic
-from tabulate import tabulate
-from utilities_common import constants
-
-
-def get_namespace_for_bgp_neighbor(neighbor_ip):
-    namespace_list = multi_asic.get_namespace_list()
-    for namespace in namespace_list:
-        if is_bgp_neigh_present(neighbor_ip, namespace):
-            return namespace
-
-    # neighbor IP not present in any namespace
-    raise ValueError(
-                 ' Bgp neighbor {} not configured'.format(neighbor_ip))
-
-
-def is_bgp_neigh_present(neighbor_ip, namespace=multi_asic.DEFAULT_NAMESPACE):
-    config_db = multi_asic.connect_config_db_for_ns(namespace)
-    #check the internal
-    bgp_session = config_db.get_entry(multi_asic.BGP_NEIGH_CFG_DB_TABLE,
-                                      neighbor_ip)
-    if bgp_session:
-        return True
-
-    bgp_session = config_db.get_entry(
-        multi_asic.BGP_INTERNAL_NEIGH_CFG_DB_TABLE, neighbor_ip)
-    if bgp_session:
-        return True
-    return False
-
-
-def is_ipv4_address(ip_address):
-    """
-    Checks if given ip is ipv4
-    :param ip_address: str ipv4
-    :return: bool
-    """
-    try:
-        ipaddress.IPv4Address(ip_address)
-        return True
-    except ipaddress.AddressValueError as err:
-        return False
-
-
-def is_ipv6_address(ip_address):
-    """
-    Checks if given ip is ipv6
-    :param ip_address: str ipv6
-    :return: bool
-    """
-    try:
-        ipaddress.IPv6Address(ip_address)
-        return True
-    except ipaddress.AddressValueError as err:
-        return False
-
-
-def get_dynamic_neighbor_subnet(db):
-    """
-    Returns dict of description and subnet info from bgp_peer_range table
-    :param db: config_db
-    """
-    dynamic_neighbor = {}
-    v4_subnet = {}
-    v6_subnet = {}
-    neighbor_data = db.get_table('BGP_PEER_RANGE')
-    try:
-        for entry in neighbor_data:
-            new_key = neighbor_data[entry]['ip_range'][0]
-            new_value = neighbor_data[entry]['name']
-            if is_ipv4_address(neighbor_data[entry]['src_address']):
-                v4_subnet[new_key] = new_value
-            elif is_ipv6_address(neighbor_data[entry]['src_address']):
-                v6_subnet[new_key] = new_value
-        dynamic_neighbor[constants.IPV4] = v4_subnet
-        dynamic_neighbor[constants.IPV6] = v6_subnet
-        return dynamic_neighbor
-    except Exception:
-        return neighbor_data
-
-
-def get_bgp_neighbors_dict(namespace=multi_asic.DEFAULT_NAMESPACE):
-    """
-    Uses config_db to get the bgp neighbors and names in dictionary format
-    :return:
-    """
-    dynamic_neighbors = {}
-    config_db = multi_asic.connect_config_db_for_ns(namespace)
-    static_neighbors = get_neighbor_dict_from_table(config_db, 'BGP_NEIGHBOR')
-    static_internal_neighbors = get_neighbor_dict_from_table(config_db, 'BGP_INTERNAL_NEIGHBOR')
-    static_neighbors.update(static_internal_neighbors)
-    static_internal_neighbors = get_neighbor_dict_from_table(config_db, 'BGP_VOQ_CHASSIS_NEIGHBOR')
-    static_neighbors.update(static_internal_neighbors)
-    bgp_monitors = get_neighbor_dict_from_table(config_db, 'BGP_MONITORS')
-    static_neighbors.update(bgp_monitors)
-    dynamic_neighbors = get_dynamic_neighbor_subnet(config_db)
-    return static_neighbors, dynamic_neighbors
-
-
-def get_bgp_neighbor_ip_to_name(ip, static_neighbors, dynamic_neighbors):
-    """
-    return neighbor name for the ip provided
-    :param ip: ip address str
-    :param static_neighbors: statically defined bgp neighbors dict
-    :param dynamic_neighbors: subnet of dynamically defined neighbors dict
-    :return: name of neighbor
-    """
-    if ip in static_neighbors:
-        return static_neighbors[ip]
-    elif is_ipv4_address(ip):
-        for subnet in dynamic_neighbors[constants.IPV4]:
-            if ipaddress.IPv4Address(ip) in ipaddress.IPv4Network(subnet):
-                return dynamic_neighbors[constants.IPV4][subnet]
-    elif is_ipv6_address(ip):
-        for subnet in dynamic_neighbors[constants.IPV6]:
-            if ipaddress.IPv6Address(ip) in ipaddress.IPv6Network(subnet):
-                return dynamic_neighbors[constants.IPV6][subnet]
-    else:
-        return "NotAvailable"
-
-
-def get_bgp_summary_extended(command_output):
-    """
-    Adds Neighbor name to the show ip[v6] bgp summary command
-    :param command: command to get bgp summary
-    """
-    static_neighbors, dynamic_neighbors = get_bgp_neighbors_dict()
-    modified_output = []
-    my_list = iter(command_output.splitlines())
-    for element in my_list:
-        if element.startswith("Neighbor"):
-            element = "{}\tNeighborName".format(element)
-            modified_output.append(element)
-        elif not element or element.startswith("Total number "):
-            modified_output.append(element)
-        elif re.match(r"(\*?([0-9A-Fa-f]{1,4}:|\d+.\d+.\d+.\d+))", element.split()[0]):
-            first_element = element.split()[0]
-            ip = first_element[1:] if first_element.startswith(
-                "*") else first_element
-            name = get_bgp_neighbor_ip_to_name(ip,
-                                               static_neighbors,
-                                               dynamic_neighbors)
-            if len(element.split()) == 1:
-                modified_output.append(element)
-                element = next(my_list)
-            element = "{}\t{}".format(element, name)
-            modified_output.append(element)
-        else:
-            modified_output.append(element)
-    click.echo("\n".join(modified_output))
-
-
-def get_neighbor_dict_from_table(db, table_name):
-    """
-    returns a dict with bgp neighbor ip as key and neighbor name as value
-    :param table_name: config db table name
-    :param db: config_db
-    """
-    neighbor_dict = {}
-    neighbor_data = db.get_table(table_name)
-    try:
-        for entry in neighbor_data:
-            neighbor_dict[entry] = neighbor_data[entry].get(
-                'name') if 'name' in neighbor_data[entry] else 'NotAvailable'
-        return neighbor_dict
-    except Exception:
-        return neighbor_dict
-
-
-def run_bgp_command(vtysh_cmd, bgp_namespace=multi_asic.DEFAULT_NAMESPACE, vtysh_shell_cmd=constants.VTYSH_COMMAND):
-    bgp_instance_id = ' '
-    output = None
-    if bgp_namespace is not multi_asic.DEFAULT_NAMESPACE:
-        bgp_instance_id = " -n {} ".format(
-            multi_asic.get_asic_id_from_name(bgp_namespace))
-
-    cmd = 'sudo {} {} -c "{}"'.format(
-        vtysh_shell_cmd, bgp_instance_id, vtysh_cmd)
-    try:
-        output, ret = clicommon.run_command(cmd, return_cmd=True)
-        if ret != 0:
-            click.echo(output.rstrip('\n'))
-            sys.exit(ret)
-    except Exception:
-        ctx = click.get_current_context()
-        ctx.fail("Unable to get summary from bgp {}".format(bgp_instance_id))
-
-    return output
-
-def run_bgp_show_command(vtysh_cmd, bgp_namespace=multi_asic.DEFAULT_NAMESPACE):
-    output = run_bgp_command(vtysh_cmd, bgp_namespace, constants.RVTYSH_COMMAND)
-    # handle the the alias mode in the following code
-    if output is not None:
-        if clicommon.get_interface_naming_mode() == "alias" and re.search("show ip|ipv6 route", vtysh_cmd):
-            iface_alias_converter = clicommon.InterfaceAliasConverter()
-            route_info =json.loads(output)
-            for route, info in route_info.items():
-                for i in range(0, len(info)):
-                    if 'nexthops' in info[i]:
-                        for j in range(0, len(info[i]['nexthops'])):
-                            intf_name = ""
-                            if 'interfaceName' in info[i]['nexthops'][j]:
-                                intf_name  = info[i]['nexthops'][j]['interfaceName']
-                                alias = iface_alias_converter.name_to_alias(intf_name)
-                                if alias is not None:
-                                    info[i]['nexthops'][j]['interfaceName'] = alias 
-            output= json.dumps(route_info)
-    return output
-
-def get_bgp_summary_from_all_bgp_instances(af, namespace, display):
-
-    device = multi_asic_util.MultiAsic(display, namespace)
-    ctx = click.get_current_context()
-    if af is constants.IPV4:
-        vtysh_cmd = "show ip bgp summary json"
-        key = 'ipv4Unicast'
-    else:
-        vtysh_cmd = "show bgp ipv6 summary json"
-        key = 'ipv6Unicast'
-
-    bgp_summary = {}
-    cmd_output_json = {}
-    for ns in device.get_ns_list_based_on_options():
-        cmd_output = run_bgp_show_command(vtysh_cmd, ns)
-        try:
-            cmd_output_json = json.loads(cmd_output)
-        except ValueError:
-            ctx.fail("bgp summary from bgp container not in json format")
-
-        # exit cli command without printing the error message
-        if key not in cmd_output_json:
-            click.echo("No IP{} neighbor is configured".format(af))
-            exit()
-
-        device.current_namespace = ns
-
-        process_bgp_summary_json(bgp_summary, cmd_output_json[key], device)
-    return bgp_summary
-
-
-def display_bgp_summary(bgp_summary, af):
-    '''
-    Display the json output in the format display by FRR
-
-    Args:
-        bgp_summary ([dict]): [Bgp summary from all bgp instances in ]
-        af: IPV4 or IPV6
-
-    '''
-    headers = ["Neighbhor", "V", "AS", "MsgRcvd", "MsgSent", "TblVer",
-               "InQ", "OutQ", "Up/Down", "State/PfxRcd", "NeighborName"]
-
-    try:
-        click.echo("\nIP{} Unicast Summary:".format(af))
-        # display the bgp instance information
-        for router_info in bgp_summary['router_info']:
-            for k in router_info:
-                v = router_info[k]
-                instance = "{}: ".format(k) if k is not "" else ""
-                click.echo(
-                    "{}BGP router identifier {}, local AS number {} vrf-id {}" .format(
-                        instance, v['router_id'], v['as'], v['vrf']))
-                click.echo("BGP table version {}".format(v['tbl_ver']))
-
-        click.echo("RIB entries {}, using {} bytes of memory"
-                   .format(bgp_summary['ribCount'], bgp_summary['ribMemory']))
-        click.echo(
-            "Peers {}, using {} KiB of memory" .format(
-                bgp_summary['peerCount'],
-                bgp_summary['peerMemory']))
-        click.echo("Peer groups {}, using {} bytes of memory" .format(
-            bgp_summary['peerGroupCount'], bgp_summary['peerGroupMemory']))
-        click.echo("\n")
-
-        click.echo(tabulate(natsorted(bgp_summary['peers']), headers=headers))
-        click.echo("\nTotal number of neighbors {}".
-                   format(len(bgp_summary['peers'])))
-    except KeyError as e:
-        ctx = click.get_current_context()
-        ctx.fail("{} missing in the bgp_summary".format(e.args[0]))
-
-
-def process_bgp_summary_json(bgp_summary, cmd_output, device):
-    '''
-    This function process the frr output in json format from a bgp
-    instance and stores the need values in the a bgp_summary
-
-    '''
-    static_neighbors, dynamic_neighbors = get_bgp_neighbors_dict(
-        device.current_namespace)
-    try:
-        # add all the router level fields
-        bgp_summary['peerCount'] = bgp_summary.get(
-            'peerCount', 0) + cmd_output['peerCount']
-        bgp_summary['peerMemory'] = bgp_summary.get(
-            'peerMemory', 0) + cmd_output['peerMemory']
-        bgp_summary['ribCount'] = bgp_summary.get(
-            'ribCount', 0) + cmd_output['ribCount']
-        bgp_summary['ribMemory'] = bgp_summary.get(
-            'ribMemory', 0) + cmd_output['ribMemory']
-        bgp_summary['peerGroupCount'] = bgp_summary.get(
-            'peerGroupCount', 0) + cmd_output['peerGroupCount']
-        bgp_summary['peerGroupMemory'] = bgp_summary.get(
-            'peerGroupMemory', 0) + cmd_output['peerGroupMemory']
-
-        # store instance level field is seperate dict
-        router_info = {}
-        router_info['router_id'] = cmd_output['routerId']
-        router_info['vrf'] = cmd_output['vrfId']
-        router_info['as'] = cmd_output['as']
-        router_info['tbl_ver'] = cmd_output['tableVersion']
-        bgp_summary.setdefault('router_info', []).append(
-            {device.current_namespace: router_info})
-
-        # store all the peers in the list
-        for peer_ip, value in cmd_output['peers'].items():
-            peers = []
-            # if display option is 'frontend', internal bgp neighbors will not
-            # be displayed
-            if device.skip_display(constants.BGP_NEIGH_OBJ, peer_ip):
-                continue
-
-            peers.append(peer_ip)
-            peers.append(value['version'])
-            peers.append(value['remoteAs'])
-            peers.append(value['msgRcvd'])
-            peers.append(value['msgSent'])
-            peers.append(value['tableVersion'])
-            peers.append(value['inq'])
-            peers.append(value['outq'])
-            peers.append(value['peerUptime'])
-            if value['state'] == 'Established':
-                peers.append(value['pfxRcd'])
-            else:
-                peers.append(value['state'])
-
-            # Get the bgp neighbour name ans store it
-            neigh_name = get_bgp_neighbor_ip_to_name(
-                peer_ip, static_neighbors, dynamic_neighbors)
-            peers.append(neigh_name)
-
-            bgp_summary.setdefault('peers', []).append(peers)
-    except KeyError as e:
-        ctx = click.get_current_context()
-        ctx.fail("{} missing in the bgp_summary".format(e.args[0]))
diff --git a/utilities_common/chassis.py b/utilities_common/chassis.py
deleted file mode 100644
index 1283bca5..00000000
--- a/utilities_common/chassis.py
+++ /dev/null
@@ -1,18 +0,0 @@
-import os
-from sonic_py_common import device_info
-
-def get_chassis_local_interfaces():
-    lst = []
-    platform = device_info.get_platform()
-    chassisdb_conf=os.path.join('/usr/share/sonic/device/', platform, "chassisdb.conf")
-    if os.path.exists(chassisdb_conf):
-        lines=[]
-        with open(chassisdb_conf, 'r') as f:
-            lines = f.readlines()
-        for line in lines:
-            line = line.strip()
-            if "chassis_internal_intfs" in line:
-                data = line.split("=")
-                lst = data[1].split(",")
-                return lst
-    return lst
diff --git a/utilities_common/cli.py b/utilities_common/cli.py
deleted file mode 100644
index 45b2cc5f..00000000
--- a/utilities_common/cli.py
+++ /dev/null
@@ -1,706 +0,0 @@
-import configparser
-import datetime
-import os
-import re
-import subprocess
-import sys
-import shutil
-
-import click
-import json
-import lazy_object_proxy
-import netaddr
-
-from natsort import natsorted
-from sonic_py_common import multi_asic
-from utilities_common.db import Db
-from utilities_common.general import load_db_config
-
-VLAN_SUB_INTERFACE_SEPARATOR = '.'
-
-pass_db = click.make_pass_decorator(Db, ensure=True)
-
-class AbbreviationGroup(click.Group):
-    """This subclass of click.Group supports abbreviated subgroup/subcommand names
-    """
-
-    def get_command(self, ctx, cmd_name):
-        # Try to get builtin commands as normal
-        rv = click.Group.get_command(self, ctx, cmd_name)
-        if rv is not None:
-            return rv
-
-        # Allow automatic abbreviation of the command.  "status" for
-        # instance will match "st".  We only allow that however if
-        # there is only one command.
-        # If there are multiple matches and the shortest one is the common prefix of all the matches, return
-        # the shortest one
-        matches = []
-        shortest = None
-        for x in self.list_commands(ctx):
-            if x.lower().startswith(cmd_name.lower()):
-                matches.append(x)
-                if not shortest:
-                    shortest = x
-                elif len(shortest) > len(x):
-                    shortest = x
-
-        if not matches:
-            return None
-        elif len(matches) == 1:
-            return click.Group.get_command(self, ctx, matches[0])
-        else:
-            for x in matches:
-                if not x.startswith(shortest):
-                    break
-            else:
-                return click.Group.get_command(self, ctx, shortest)
-
-            ctx.fail('Too many matches: %s' % ', '.join(sorted(matches)))
-
-
-# This is from the aliases example:
-# https://github.com/pallets/click/blob/57c6f09611fc47ca80db0bd010f05998b3c0aa95/examples/aliases/aliases.py
-class Config(object):
-    """Object to hold CLI config"""
-
-    def __init__(self):
-        self.path = os.getcwd()
-        self.aliases = {}
-
-    def read_config(self, filename):
-        parser = configparser.RawConfigParser()
-        parser.read([filename])
-        try:
-            self.aliases.update(parser.items('aliases'))
-        except configparser.NoSectionError:
-            pass
-
-# Global Config object
-_config = None
-
-class AliasedGroup(click.Group):
-    """This subclass of click.Group supports abbreviations and
-       looking up aliases in a config file with a bit of magic.
-    """
-
-    def get_command(self, ctx, cmd_name):
-        global _config
-
-        # If we haven't instantiated our global config, do it now and load current config
-        if _config is None:
-            _config = Config()
-
-            # Load our config file
-            cfg_file = os.path.join(os.path.dirname(__file__), 'aliases.ini')
-            _config.read_config(cfg_file)
-
-        # Try to get builtin commands as normal
-        rv = click.Group.get_command(self, ctx, cmd_name)
-        if rv is not None:
-            return rv
-
-        # No builtin found. Look up an explicit command alias in the config
-        if cmd_name in _config.aliases:
-            actual_cmd = _config.aliases[cmd_name]
-            return click.Group.get_command(self, ctx, actual_cmd)
-
-        # Alternative option: if we did not find an explicit alias we
-        # allow automatic abbreviation of the command.  "status" for
-        # instance will match "st".  We only allow that however if
-        # there is only one command.
-        matches = [x for x in self.list_commands(ctx)
-                   if x.lower().startswith(cmd_name.lower())]
-        if not matches:
-            return None
-        elif len(matches) == 1:
-            return click.Group.get_command(self, ctx, matches[0])
-        ctx.fail('Too many matches: %s' % ', '.join(sorted(matches)))
-
-class InterfaceAliasConverter(object):
-    """Class which handles conversion between interface name and alias"""
-
-    def __init__(self, db=None):
-
-        # Load database config files
-        load_db_config()
-        if db is None:
-            self.port_dict = multi_asic.get_port_table()
-        else:
-            self.config_db = db.cfgdb
-            self.port_dict = self.config_db.get_table('PORT')
-        self.alias_max_length = 0
-
-
-        if not self.port_dict:
-            self.port_dict = {}
-
-        for port_name in self.port_dict:
-            try:
-                if self.alias_max_length < len(
-                        self.port_dict[port_name]['alias']):
-                   self.alias_max_length = len(
-                        self.port_dict[port_name]['alias'])
-            except KeyError:
-                break
-
-    def name_to_alias(self, interface_name):
-        """Return vendor interface alias if SONiC
-           interface name is given as argument
-        """
-        vlan_id = ''
-        sub_intf_sep_idx = -1
-        if interface_name is not None:
-            sub_intf_sep_idx = interface_name.find(VLAN_SUB_INTERFACE_SEPARATOR)
-            if sub_intf_sep_idx != -1:
-                vlan_id = interface_name[sub_intf_sep_idx + 1:]
-                # interface_name holds the parent port name
-                interface_name = interface_name[:sub_intf_sep_idx]
-
-            for port_name in self.port_dict:
-                if interface_name == port_name:
-                    return self.port_dict[port_name]['alias'] if sub_intf_sep_idx == -1 \
-                            else self.port_dict[port_name]['alias'] + VLAN_SUB_INTERFACE_SEPARATOR + vlan_id
-
-        # interface_name not in port_dict. Just return interface_name
-        return interface_name if sub_intf_sep_idx == -1 else interface_name + VLAN_SUB_INTERFACE_SEPARATOR + vlan_id
-
-    def alias_to_name(self, interface_alias):
-        """Return SONiC interface name if vendor
-           port alias is given as argument
-        """
-        vlan_id = ''
-        sub_intf_sep_idx = -1
-        if interface_alias is not None:
-            sub_intf_sep_idx = interface_alias.find(VLAN_SUB_INTERFACE_SEPARATOR)
-            if sub_intf_sep_idx != -1:
-                vlan_id = interface_alias[sub_intf_sep_idx + 1:]
-                # interface_alias holds the parent port alias
-                interface_alias = interface_alias[:sub_intf_sep_idx]
-
-            for port_name in self.port_dict:
-                if interface_alias == self.port_dict[port_name]['alias']:
-                    return port_name if sub_intf_sep_idx == -1 else port_name + VLAN_SUB_INTERFACE_SEPARATOR + vlan_id
-
-        # interface_alias not in port_dict. Just return interface_alias
-        return interface_alias if sub_intf_sep_idx == -1 else interface_alias + VLAN_SUB_INTERFACE_SEPARATOR + vlan_id
-
-# Lazy global class instance for SONiC interface name to alias conversion
-iface_alias_converter = lazy_object_proxy.Proxy(lambda: InterfaceAliasConverter())
-
-def get_interface_naming_mode():
-    mode = os.getenv('SONIC_CLI_IFACE_MODE')
-    if mode is None:
-        mode = "default"
-    return mode
-
-def is_ipaddress(val):
-    """ Validate if an entry is a valid IP """
-    import netaddr
-    if not val:
-        return False
-    try:
-        netaddr.IPAddress(str(val))
-    except netaddr.core.AddrFormatError:
-        return False
-    return True
-
-def ipaddress_type(val):
-    """ Return the IP address type """
-    if not val:
-        return None
-
-    try:
-        ip_version = netaddr.IPAddress(str(val))
-    except netaddr.core.AddrFormatError:
-        return None
-
-    return ip_version.version
-
-def is_ip_prefix_in_key(key):
-    '''
-    Function to check if IP address is present in the key. If it
-    is present, then the key would be a tuple or else, it shall be
-    be string
-    '''
-    return (isinstance(key, tuple))
-
-def is_valid_port(config_db, port):
-    """Check if port is in PORT table"""
-
-    port_table = config_db.get_table('PORT')
-    if port in port_table:
-        return True
-
-    return False
-
-def is_valid_portchannel(config_db, port):
-    """Check if port is in PORT_CHANNEL table"""
-
-    pc_table = config_db.get_table('PORTCHANNEL')
-    if port in pc_table:
-        return True
-
-    return False
-
-def is_vlanid_in_range(vid):
-    """Check if vlan id is valid or not"""
-
-    if vid >= 1 and vid <= 4094:
-        return True
-
-    return False
-
-def check_if_vlanid_exist(config_db, vlan, table_name='VLAN'):
-    """Check if vlan id exits in the config db or ot"""
-
-    if len(config_db.get_entry(table_name, vlan)) != 0:
-        return True
-
-    return False
-
-def is_port_vlan_member(config_db, port, vlan):
-    """Check if port is a member of vlan"""
-
-    vlan_ports_data = config_db.get_table('VLAN_MEMBER')
-    for key in vlan_ports_data:
-        if key[0] == vlan and key[1] == port:
-            return True
-
-    return False
-
-def interface_is_in_vlan(vlan_member_table, interface_name):
-    """ Check if an interface is in a vlan """
-    for _,intf in vlan_member_table:
-        if intf == interface_name:
-            return True
-
-    return False
-
-def is_valid_vlan_interface(config_db, interface):
-    """ Check an interface is a valid VLAN interface """
-    return interface in config_db.get_table("VLAN_INTERFACE")
-
-def interface_is_in_portchannel(portchannel_member_table, interface_name):
-    """ Check if an interface is part of portchannel """
-    for _,intf in portchannel_member_table:
-        if intf == interface_name:
-            return True
-
-    return False
-
-def is_port_router_interface(config_db, port):
-    """Check if port is a router interface"""
-
-    interface_table = config_db.get_table('INTERFACE')
-    for intf in interface_table:
-        if port == intf:
-            return True
-
-    return False
-
-def is_pc_router_interface(config_db, pc):
-    """Check if portchannel is a router interface"""
-
-    pc_interface_table = config_db.get_table('PORTCHANNEL_INTERFACE')
-    for intf in pc_interface_table:
-        if pc == intf:
-            return True
-
-    return False
-
-def is_port_mirror_dst_port(config_db, port):
-    """Check if port is already configured as mirror destination port """
-    mirror_table = config_db.get_table('MIRROR_SESSION')
-    for _,v in mirror_table.items():
-        if 'dst_port' in v and v['dst_port'] == port:
-            return True
-
-    return False
-
-def vni_id_is_valid(vni):
-    """Check if the vni id is in acceptable range (between 1 and 2^24)
-    """
-
-    if (vni < 1) or (vni > 16777215):
-        return False
-
-    return True
-
-def is_vni_vrf_mapped(db, vni):
-    """Check if the vni is mapped to vrf
-    """
-
-    found = 0
-    vrf_table = db.cfgdb.get_table('VRF')
-    vrf_keys = vrf_table.keys()
-    if vrf_keys is not None:
-      for vrf_key in vrf_keys:
-        if ('vni' in vrf_table[vrf_key] and vrf_table[vrf_key]['vni'] == vni):
-           found = 1
-           break
-
-    if (found == 1):
-        print("VNI {} mapped to Vrf {}, Please remove VRF VNI mapping".format(vni, vrf_key))
-        return False
-
-    return True
-
-def interface_has_mirror_config(mirror_table, interface_name):
-    """Check if port is already configured with mirror config """
-    for _,v in mirror_table.items():
-        if 'src_port' in v and v['src_port'] == interface_name:
-            return True
-        if 'dst_port' in v and v['dst_port'] == interface_name:
-            return True
-
-    return False
-
-def print_output_in_alias_mode(output, index):
-    """Convert and print all instances of SONiC interface
-       name to vendor-sepecific interface aliases.
-    """
-
-    alias_name = ""
-    interface_name = ""
-
-    # Adjust tabulation width to length of alias name
-    if output.startswith("---"):
-        word = output.split()
-        dword = word[index]
-        if(len(dword) > iface_alias_converter.alias_max_length):
-            dword = dword[:len(dword) - iface_alias_converter.alias_max_length]
-        underline = dword.rjust(iface_alias_converter.alias_max_length,
-                                '-')
-        word[index] = underline
-        output = '  ' .join(word)
-
-    # Replace SONiC interface name with vendor alias
-    word = output.split()
-    if word:
-        interface_name = word[index]
-        interface_name = interface_name.replace(':', '')
-    for port_name in natsorted(list(iface_alias_converter.port_dict.keys())):
-            if interface_name == port_name:
-                alias_name = iface_alias_converter.port_dict[port_name]['alias']
-    if alias_name:
-        if len(alias_name) < iface_alias_converter.alias_max_length:
-            alias_name = alias_name.rjust(
-                                iface_alias_converter.alias_max_length)
-        output = output.replace(interface_name, alias_name, 1)
-
-    click.echo(output.rstrip('\n'))
-
-def run_command_in_alias_mode(command):
-    """Run command and replace all instances of SONiC interface names
-       in output with vendor-sepecific interface aliases.
-    """
-
-    process = subprocess.Popen(command, shell=True, text=True, stdout=subprocess.PIPE)
-
-    while True:
-        output = process.stdout.readline()
-        if output == '' and process.poll() is not None:
-            break
-
-        if output:
-            index = 1
-            raw_output = output
-            output = output.lstrip()
-
-            if command.startswith("portstat"):
-                """Show interface counters"""
-                index = 0
-                if output.startswith("IFACE"):
-                    output = output.replace("IFACE", "IFACE".rjust(
-                               iface_alias_converter.alias_max_length))
-                print_output_in_alias_mode(output, index)
-
-            elif command.startswith("intfstat"):
-                """Show RIF counters"""
-                index = 0
-                if output.startswith("IFACE"):
-                    output = output.replace("IFACE", "IFACE".rjust(
-                               iface_alias_converter.alias_max_length))
-                print_output_in_alias_mode(output, index)
-
-            elif command == "pfcstat":
-                """Show pfc counters"""
-                index = 0
-                if output.startswith("Port Tx"):
-                    output = output.replace("Port Tx", "Port Tx".rjust(
-                                iface_alias_converter.alias_max_length))
-
-                elif output.startswith("Port Rx"):
-                    output = output.replace("Port Rx", "Port Rx".rjust(
-                                iface_alias_converter.alias_max_length))
-                print_output_in_alias_mode(output, index)
-
-            elif (command.startswith("sudo sfputil show eeprom")):
-                """Show interface transceiver eeprom"""
-                index = 0
-                print_output_in_alias_mode(raw_output, index)
-
-            elif (command.startswith("sudo sfputil show")):
-                """Show interface transceiver lpmode,
-                   presence
-                """
-                index = 0
-                if output.startswith("Port"):
-                    output = output.replace("Port", "Port".rjust(
-                               iface_alias_converter.alias_max_length))
-                print_output_in_alias_mode(output, index)
-
-            elif command == "sudo lldpshow":
-                """Show lldp table"""
-                index = 0
-                if output.startswith("LocalPort"):
-                    output = output.replace("LocalPort", "LocalPort".rjust(
-                               iface_alias_converter.alias_max_length))
-                print_output_in_alias_mode(output, index)
-
-            elif command.startswith("queuestat"):
-                """Show queue counters"""
-                index = 0
-                if output.startswith("Port"):
-                    output = output.replace("Port", "Port".rjust(
-                               iface_alias_converter.alias_max_length))
-                print_output_in_alias_mode(output, index)
-
-            elif command == "fdbshow":
-                """Show mac"""
-                index = 3
-                if output.startswith("No."):
-                    output = "  " + output
-                    output = re.sub(
-                                'Type', '      Type', output)
-                elif output[0].isdigit():
-                    output = "    " + output
-                print_output_in_alias_mode(output, index)
-
-            elif command.startswith("nbrshow"):
-                """Show arp"""
-                index = 2
-                if "Vlan" in output:
-                    output = output.replace('Vlan', '  Vlan')
-                print_output_in_alias_mode(output, index)
-            elif command.startswith("sudo ipintutil"):
-                """Show ip(v6) int"""
-                index = 0
-                if output.startswith("Interface"):
-                   output = output.replace("Interface", "Interface".rjust(
-                               iface_alias_converter.alias_max_length))
-                print_output_in_alias_mode(output, index)
-
-            else:
-                """
-                Default command conversion
-                Search for port names either at the start of a line or preceded immediately by
-                whitespace and followed immediately by either the end of a line or whitespace
-                or a comma followed by whitespace
-                """
-                converted_output = raw_output
-                for port_name in iface_alias_converter.port_dict:
-                    converted_output = re.sub(r"(^|\s){}($|,{{0,1}}\s)".format(port_name),
-                            r"\1{}\2".format(iface_alias_converter.name_to_alias(port_name)),
-                            converted_output)
-                click.echo(converted_output.rstrip('\n'))
-
-    rc = process.poll()
-    if rc != 0:
-        sys.exit(rc)
-
-
-def run_command(command, display_cmd=False, ignore_error=False, return_cmd=False, interactive_mode=False):
-    """
-    Run bash command. Default behavior is to print output to stdout. If the command returns a non-zero
-    return code, the function will exit with that return code.
-
-    Args:
-        display_cmd: Boolean; If True, will print the command being run to stdout before executing the command
-        ignore_error: Boolean; If true, do not exit if command returns a non-zero return code
-        return_cmd: Boolean; If true, the function will return the output, ignoring any non-zero return code
-        interactive_mode: Boolean; If true, it will treat the process as a long-running process which may generate
-                          multiple lines of output over time
-    """
-
-    if display_cmd == True:
-        click.echo(click.style("Running command: ", fg='cyan') + click.style(command, fg='green'))
-
-    # No conversion needed for intfutil commands as it already displays
-    # both SONiC interface name and alias name for all interfaces.
-    # IP route table cannot be handled in function run_command_in_alias_mode since it is in JSON format 
-    # with a list for next hops 
-    if get_interface_naming_mode() == "alias" and not command.startswith("intfutil") and not re.search("show ip|ipv6 route", command):
-        run_command_in_alias_mode(command)
-        sys.exit(0)
-
-    proc = subprocess.Popen(command, shell=True, text=True, stdout=subprocess.PIPE)
-
-    if return_cmd:
-        output = proc.communicate()[0]
-        return output, proc.returncode
-
-    if not interactive_mode:
-        (out, err) = proc.communicate()
-
-        if len(out) > 0:
-            click.echo(out.rstrip('\n'))
-
-        if proc.returncode != 0 and not ignore_error:
-            sys.exit(proc.returncode)
-
-        return
-
-    # interactive mode
-    while True:
-        output = proc.stdout.readline()
-        if output == "" and proc.poll() is not None:
-            break
-        if output:
-            click.echo(output.rstrip('\n'))
-
-    rc = proc.poll()
-    if rc != 0:
-        sys.exit(rc)
-
-
-def json_serial(obj):
-    """JSON serializer for objects not serializable by default"""
-
-    if isinstance(obj, (datetime.datetime, datetime.date)):
-        return obj.isoformat()
-    raise TypeError("Type %s not serializable" % type(obj))
-
-
-def json_dump(data):
-    """
-    Dump data in JSON format
-    """
-    return json.dumps(
-        data, sort_keys=True, indent=2, ensure_ascii=False, default=json_serial
-    )
-
-
-def interface_is_untagged_member(db, interface_name):
-    """ Check if interface is already untagged member"""
-    vlan_member_table = db.get_table('VLAN_MEMBER')
-
-    for key,val in vlan_member_table.items():
-        if(key[1] == interface_name):
-            if (val['tagging_mode'] == 'untagged'):
-                return True
-    return False
-
-def is_interface_in_config_db(config_db, interface_name):
-    """ Check if an interface is in CONFIG DB """
-    if (not interface_name in config_db.get_keys('VLAN_INTERFACE') and
-        not interface_name in config_db.get_keys('INTERFACE') and
-        not interface_name in config_db.get_keys('PORTCHANNEL_INTERFACE') and
-        not interface_name in config_db.get_keys('VLAN_SUB_INTERFACE') and
-        not interface_name == 'null'):
-            return False
-
-    return True
-
-
-class MutuallyExclusiveOption(click.Option):
-    """
-    This option type is extended with `mutually_exclusive` parameter which make
-    CLI to ensure the other options specified in `mutually_exclusive` are not used.
-    """
-
-    def __init__(self, *args, **kwargs):
-        self.mutually_exclusive = set(kwargs.pop('mutually_exclusive', []))
-        super(MutuallyExclusiveOption, self).__init__(*args, **kwargs)
-
-    def get_help_record(self, ctx):
-        """Return help string with mutually_exclusive list added."""
-        help_record = list(super(MutuallyExclusiveOption, self).get_help_record(ctx))
-        if self.mutually_exclusive:
-            mutually_exclusive_str = 'NOTE: this argument is mutually exclusive with arguments: %s' % ', '.join(self.mutually_exclusive)
-            if help_record[-1]:
-                help_record[-1] += ' ' + mutually_exclusive_str
-            else:
-                help_record[-1] = mutually_exclusive_str
-        return tuple(help_record)
-
-    def handle_parse_result(self, ctx, opts, args):
-        if self.name in opts and opts[self.name] is not None:
-            for opt_name in self.mutually_exclusive:
-                if opt_name in opts and opts[opt_name] is not None:
-                    raise click.UsageError(
-                        "Illegal usage: %s is mutually exclusive with arguments %s" % (self.name, ', '.join(self.mutually_exclusive))
-                        )
-        return super(MutuallyExclusiveOption, self).handle_parse_result(ctx, opts, args)
-
-
-def query_yes_no(question, default="yes"):
-    """Ask a yes/no question via input() and return their answer.
-
-    "question" is a string that is presented to the user.
-    "default" is the presumed answer if the user just hits <Enter>.
-        It must be "yes" (the default), "no" or None (meaning
-        an answer is required of the user).
-
-    The "answer" return value is True for "yes" or False for "no".
-    """
-    valid = {"yes": True, "y": True, "ye": True,
-             "no": False, "n": False}
-    if default is None:
-        prompt = " [y/n] "
-    elif default == "yes":
-        prompt = " [Y/n] "
-    elif default == "no":
-        prompt = " [y/N] "
-    else:
-        raise ValueError("invalid default answer: '%s'" % default)
-
-    while True:
-        sys.stdout.write(question + prompt)
-        choice = input().lower().strip()
-        if default is not None and choice == '':
-            return valid[default]
-        elif choice in valid:
-            return valid[choice]
-        else:
-            sys.stdout.write("Please respond with 'yes' or 'no' "
-                             "(or 'y' or 'n').\n")
-
-
-class UserCache:
-    """ General purpose cache directory created per user """
-
-    CACHE_DIR = "/tmp/cache/"
-
-    def __init__(self, app_name=None, tag=None):
-        """ Initialize UserCache and create a cache directory if it does not exist.
-
-        Args:
-            tag (str): Tag the user cache. Different tags correspond to different cache directories even for the same user.
-        """
-        self.uid = os.getuid()
-        self.app_name = os.path.basename(sys.argv[0]) if app_name is None else app_name
-        self.cache_directory_suffix = str(self.uid) if tag is None else f"{self.uid}-{tag}"
-        self.cache_directory_app = os.path.join(self.CACHE_DIR, self.app_name)
-
-        prev_umask = os.umask(0)
-        try:
-            os.makedirs(self.cache_directory_app, exist_ok=True)
-        finally:
-            os.umask(prev_umask)
-
-        self.cache_directory = os.path.join(self.cache_directory_app, self.cache_directory_suffix)
-        os.makedirs(self.cache_directory, exist_ok=True)
-
-    def get_directory(self):
-        """ Return the cache directory path """
-        return self.cache_directory
-
-    def remove(self):
-        """ Remove the content of the cache directory """
-        shutil.rmtree(self.cache_directory)
-
-    def remove_all(self):
-        """ Remove the content of the cache for all users """
-        shutil.rmtree(self.cache_directory_app)
diff --git a/utilities_common/constants.py b/utilities_common/constants.py
deleted file mode 100644
index 536965d0..00000000
--- a/utilities_common/constants.py
+++ /dev/null
@@ -1,12 +0,0 @@
-#All the constant used in sonic-utilities
-
-DEFAULT_NAMESPACE = ''
-DISPLAY_ALL = 'all'
-DISPLAY_EXTERNAL = 'frontend'
-BGP_NEIGH_OBJ = 'BGP_NEIGH'
-PORT_CHANNEL_OBJ = 'PORT_CHANNEL'
-PORT_OBJ = 'PORT'
-IPV4 = 'v4'
-IPV6 = 'v6'
-VTYSH_COMMAND = 'vtysh'
-RVTYSH_COMMAND = 'rvtysh'
diff --git a/utilities_common/db.py b/utilities_common/db.py
deleted file mode 100644
index 091a821f..00000000
--- a/utilities_common/db.py
+++ /dev/null
@@ -1,42 +0,0 @@
-from sonic_py_common import multi_asic, device_info
-from swsscommon.swsscommon import ConfigDBConnector, ConfigDBPipeConnector, SonicV2Connector
-from utilities_common import constants
-from utilities_common.multi_asic import multi_asic_ns_choices
-
-
-class Db(object):
-    def __init__(self):
-        self.cfgdb_clients = {}
-        self.db_clients = {}
-        self.cfgdb = ConfigDBConnector()
-        self.cfgdb.connect()
-        self.cfgdb_pipe = ConfigDBPipeConnector()
-        self.cfgdb_pipe.connect()
-        self.db = SonicV2Connector(host="127.0.0.1")
-
-        # Skip connecting to chassis databases in line cards
-        self.db_list = list(self.db.get_db_list())
-        if not device_info.is_supervisor():
-            try:
-                self.db_list.remove('CHASSIS_APP_DB')
-                self.db_list.remove('CHASSIS_STATE_DB')
-            except Exception:
-                pass
-
-        for db_id in self.db_list:
-            self.db.connect(db_id)
-
-        self.cfgdb_clients[constants.DEFAULT_NAMESPACE] = self.cfgdb
-        self.db_clients[constants.DEFAULT_NAMESPACE] = self.db
-
-        if multi_asic.is_multi_asic():
-            self.ns_list = multi_asic_ns_choices()
-            for ns in self.ns_list:
-                self.cfgdb_clients[ns] = (
-                    multi_asic.connect_config_db_for_ns(ns)
-                )
-                self.db_clients[ns] = multi_asic.connect_to_all_dbs_for_ns(ns)
-
-    def get_data(self, table, key):
-        data = self.cfgdb.get_table(table)
-        return data[key] if key in data else None
diff --git a/utilities_common/dhcp_relay_util.py b/utilities_common/dhcp_relay_util.py
deleted file mode 100644
index b9c0b4e2..00000000
--- a/utilities_common/dhcp_relay_util.py
+++ /dev/null
@@ -1,20 +0,0 @@
-import click
-import utilities_common.cli as clicommon
-
-
-def restart_dhcp_relay_service():
-    """
-    Restart dhcp_relay service
-    """
-    click.echo("Restarting DHCP relay service...")
-    clicommon.run_command("systemctl stop dhcp_relay", display_cmd=False)
-    clicommon.run_command("systemctl reset-failed dhcp_relay", display_cmd=False)
-    clicommon.run_command("systemctl start dhcp_relay", display_cmd=False)
-
-
-def handle_restart_dhcp_relay_service():
-    try:
-        restart_dhcp_relay_service()
-    except SystemExit as e:
-        ctx = click.get_current_context()
-        ctx.fail("Restart service dhcp_relay failed with error {}".format(e))
diff --git a/utilities_common/general.py b/utilities_common/general.py
deleted file mode 100644
index 6ed70a46..00000000
--- a/utilities_common/general.py
+++ /dev/null
@@ -1,44 +0,0 @@
-import importlib.machinery
-import importlib.util
-import sys
-
-from sonic_py_common.multi_asic import is_multi_asic
-from swsscommon import swsscommon
-
-def load_module_from_source(module_name, file_path):
-    """
-    This function will load the Python source file specified by <file_path>
-    as a module named <module_name> and return an instance of the module
-    """
-    loader = importlib.machinery.SourceFileLoader(module_name, file_path)
-    spec = importlib.util.spec_from_loader(loader.name, loader)
-    module = importlib.util.module_from_spec(spec)
-    loader.exec_module(module)
-
-    sys.modules[module_name] = module
-
-    return module
-
-def load_db_config():
-    '''
-    Load the correct database config file:
-     - database_global.json for multi asic
-     - database_config.json for single asic
-    '''
-    if is_multi_asic():
-        if not swsscommon.SonicDBConfig.isGlobalInit():
-            swsscommon.SonicDBConfig.load_sonic_global_db_config()
-    else:
-        if not swsscommon.SonicDBConfig.isInit():
-            swsscommon.SonicDBConfig.load_sonic_db_config()
-
-def get_optional_value_for_key_in_config_tbl(config_db, port, key, table):
-    info_dict = {}
-    info_dict = config_db.get_entry(table, port)
-    if info_dict is None:
-        return None
-
-    value = info_dict.get(key, None)
-        
-    return value
-
diff --git a/utilities_common/helper.py b/utilities_common/helper.py
deleted file mode 100644
index f7a71cec..00000000
--- a/utilities_common/helper.py
+++ /dev/null
@@ -1,66 +0,0 @@
-from dump.match_infra import MatchEngine, MatchRequest, ConnectionPool
-from dump.match_helper import get_matched_keys
-from .db import Db
-
-def get_port_acl_binding(db_wrap, port, ns):
-    """
-    Verify if the port is not bound to any ACL Table
-    
-    Args:
-        db_wrap: utilities_common.Db() object
-        port: Iface name
-        ns: namespace
-
-    Returns:
-        list: ACL_TABLE names if found, 
-                otherwise empty
-    """ 
-    ACL = "ACL_TABLE" # Table to look for port bindings
-    if not isinstance(db_wrap, Db):
-        raise Exception("db_wrap object is not of type utilities_common.Db")
-
-    conn_pool = ConnectionPool()
-    conn_pool.fill(ns, db_wrap.db_clients[ns], db_wrap.db_list)
-    m_engine = MatchEngine(conn_pool)
-    req = MatchRequest(db="CONFIG_DB",
-                      table=ACL,
-                      key_pattern="*",
-                      field="ports@",
-                      value=port,
-                      ns=ns,
-                      match_entire_list=False)
-    ret = m_engine.fetch(req)
-    acl_tables, _ = get_matched_keys(ret)
-    return acl_tables
-
-
-def get_port_pbh_binding(db_wrap, port, ns):
-    """
-    Verify if the port is not bound to any PBH Table
-    
-    Args:
-        db_wrap: Db() object
-        port: Iface name
-        ns: namespace
-
-    Returns:
-        list: PBH_TABLE names if found, 
-                otherwise empty
-    """ 
-    PBH = "PBH_TABLE" # Table to look for port bindings
-    if not isinstance(db_wrap, Db):
-        raise Exception("db_wrap object is not of type utilities_common.Db")
-
-    conn_pool = ConnectionPool()
-    conn_pool.fill(ns, db_wrap.db_clients[ns], db_wrap.db_list)
-    m_engine = MatchEngine(conn_pool)
-    req = MatchRequest(db="CONFIG_DB",
-                      table=PBH,
-                      key_pattern="*",
-                      field="interface_list@",
-                      value=port,
-                      ns=ns,
-                      match_entire_list=False)
-    ret = m_engine.fetch(req)
-    pbh_tables, _ = get_matched_keys(ret)
-    return pbh_tables
diff --git a/utilities_common/intf_filter.py b/utilities_common/intf_filter.py
deleted file mode 100755
index 190445c6..00000000
--- a/utilities_common/intf_filter.py
+++ /dev/null
@@ -1,55 +0,0 @@
-# Interface filtering functions
-
-SONIC_PORT_NAME_PREFIX = "Ethernet"
-SONIC_LAG_NAME_PREFIX = "PortChannel"
-SONIC_BACK_PORT_NAME_PREFIX = "Ethernet-BP"
-
-def parse_interface_in_filter(intf_filter):
-    intf_fs = []
-
-    if intf_filter is None:
-        return intf_fs
-
-    fs = intf_filter.split(',')
-    for x in fs:
-        if x.startswith(SONIC_BACK_PORT_NAME_PREFIX):
-            intf = SONIC_BACK_PORT_NAME_PREFIX
-            x = x.split(intf)[1]
-            if '-' in x:
-                start = x.split('-')[0]
-                end = x.split('-')[1]
-                if not start.isdigit() or not end.isdigit():
-                    continue
-                for i in range(int(start), int(end)+1):
-                    intf_fs.append(intf+str(i))
-            else:
-                intf_fs.append(intf+x)
-        elif '-' in x:
-            # handle range
-            if not x.startswith(SONIC_PORT_NAME_PREFIX) and not x.startswith(SONIC_LAG_NAME_PREFIX):
-                continue
-            if x.startswith(SONIC_PORT_NAME_PREFIX):
-                intf = SONIC_PORT_NAME_PREFIX
-            if x.startswith(SONIC_LAG_NAME_PREFIX):
-                intf = SONIC_LAG_NAME_PREFIX
-            start = x.split('-')[0].split(intf,1)[1]
-            end = x.split('-')[1]
-
-            if not start.isdigit() or not end.isdigit():
-                continue
-            for i in range(int(start), int(end)+1):
-                intf_fs.append(intf+str(i))
-        else:
-            intf_fs.append(x)
-
-    return intf_fs
-
-def interface_in_filter(intf, filter):
-    if filter is None:
-        return True
-
-    intf_fs = parse_interface_in_filter(filter)
-    if intf in intf_fs:
-        return True
-
-    return False
diff --git a/utilities_common/multi_asic.py b/utilities_common/multi_asic.py
deleted file mode 100644
index b1f24e12..00000000
--- a/utilities_common/multi_asic.py
+++ /dev/null
@@ -1,191 +0,0 @@
-import argparse
-import functools
-
-import click
-import netifaces
-import pyroute2
-from natsort import natsorted
-from sonic_py_common import multi_asic, device_info
-from utilities_common import constants
-from utilities_common.general import load_db_config
-
-
-class MultiAsic(object):
-
-    def __init__(
-        self, display_option=constants.DISPLAY_ALL, namespace_option=None,
-        db=None
-    ):
-        # Load database config files
-        load_db_config()
-        self.namespace_option = namespace_option
-        self.display_option = display_option
-        self.current_namespace = None
-        self.is_multi_asic = multi_asic.is_multi_asic()
-        self.db = db
-
-    def get_display_option(self):
-        return self.display_option
-
-    def is_object_internal(self, object_type, cli_object):
-        '''
-        The function checks if a CLI object is internal and returns true or false.
-        Internal objects are port or portchannel which are connected to other
-        ports or portchannels within a multi ASIC device.
-
-        For single asic, this function is not applicable
-        '''
-        if object_type == constants.PORT_OBJ:
-            return multi_asic.is_port_internal(cli_object, self.current_namespace)
-        elif object_type == constants.PORT_CHANNEL_OBJ:
-            return multi_asic.is_port_channel_internal(cli_object, self.current_namespace)
-        elif object_type == constants.BGP_NEIGH_OBJ:
-            return multi_asic.is_bgp_session_internal(cli_object, self.current_namespace)
-
-    def skip_display(self, object_type, cli_object):
-        '''
-        The function determines if the passed cli_object has to be displayed or not.
-        returns true if the display_option is external and  the cli object is internal.
-        returns false, if the cli option is all or if it the platform is single ASIC.
-
-        '''
-        if not self.is_multi_asic and not device_info.is_chassis():
-            return False
-        if self.get_display_option() == constants.DISPLAY_ALL:
-            return False
-        return self.is_object_internal(object_type, cli_object)
-
-    def get_ns_list_based_on_options(self):
-        ns_list = []
-        if not self.is_multi_asic:
-            return [constants.DEFAULT_NAMESPACE]
-        else:
-            namespaces = multi_asic.get_all_namespaces()
-            if self.namespace_option is None:
-                if self.get_display_option() == constants.DISPLAY_ALL:
-                    ns_list = namespaces['front_ns'] + namespaces['back_ns'] + namespaces['fabric_ns']
-                else:
-                    ns_list = namespaces['front_ns']
-            else:
-                if self.namespace_option not in namespaces['front_ns'] and \
-                        self.namespace_option not in namespaces['back_ns'] and \
-                        self.namespace_option not in namespaces['fabric_ns']:
-                    raise ValueError(
-                        'Unknown Namespace {}'.format(self.namespace_option))
-                ns_list = [self.namespace_option]
-        return ns_list
-
-
-def multi_asic_ns_choices():
-    if not multi_asic.is_multi_asic():
-        return [constants.DEFAULT_NAMESPACE]
-    choices = multi_asic.get_namespace_list()
-    return choices
-
-
-def multi_asic_display_choices():
-    if not multi_asic.is_multi_asic() and not device_info.is_chassis():
-        return [constants.DISPLAY_ALL]
-    else:
-        return [constants.DISPLAY_ALL, constants.DISPLAY_EXTERNAL]
-
-
-def multi_asic_display_default_option():
-    if not multi_asic.is_multi_asic() and not device_info.is_chassis():
-        return constants.DISPLAY_ALL
-    else:
-        return constants.DISPLAY_EXTERNAL
-
-
-_multi_asic_click_option_display = click.option('--display',
-                                                '-d', 'display',
-                                                default=multi_asic_display_default_option(),
-                                                show_default=True,
-                                                type=click.Choice(multi_asic_display_choices()),
-                                                help='Show internal interfaces')
-_multi_asic_click_option_namespace = click.option('--namespace',
-                                                  '-n', 'namespace',
-                                                  default=None,
-                                                  type=click.Choice(multi_asic_ns_choices()),
-                                                  show_default=True,
-                                                  help='Namespace name or all')
-_multi_asic_click_options = [
-      _multi_asic_click_option_display,
-      _multi_asic_click_option_namespace,
-]
-
-def multi_asic_namespace_validation_callback(ctx, param, value):
-    if not multi_asic.is_multi_asic:
-        click.echo("-n/--namespace is not available for single asic")
-        ctx.abort()
-    return value
-
-def multi_asic_click_options(func):
-    for option in reversed(_multi_asic_click_options):
-        func = option(func)
-    return func
-
-def multi_asic_click_option_namespace(func):
-   func = _multi_asic_click_option_namespace(func)
-   return func
-
-def run_on_multi_asic(func):
-    '''
-    This decorator is used on the CLI functions which needs to be
-    run on all the namespaces in the multi ASIC platform
-    The decorator loops through all the required namespaces,
-    for every iteration, it connects to all the DBs and provides an handle
-    to the wrapped function.
-
-    '''
-    @functools.wraps(func)
-    def wrapped_run_on_all_asics(self, *args, **kwargs):
-        ns_list = self.multi_asic.get_ns_list_based_on_options()
-        for ns in ns_list:
-            self.multi_asic.current_namespace = ns
-            # if object instance already has db connections, use them
-            if self.multi_asic.db and self.multi_asic.db.cfgdb_clients.get(ns):
-                self.config_db = self.multi_asic.db.cfgdb_clients[ns]
-            else:
-                self.config_db = multi_asic.connect_config_db_for_ns(ns)
-
-            if self.multi_asic.db and self.multi_asic.db.db_clients.get(ns):
-                self.db = self.multi_asic.db.db_clients[ns]
-            else:
-                self.db = multi_asic.connect_to_all_dbs_for_ns(ns)
-
-            func(self,  *args, **kwargs)
-    return wrapped_run_on_all_asics
-
-
-def multi_asic_args(parser=None):
-    if parser is None:
-        parser = argparse.ArgumentParser(
-            formatter_class=argparse.RawTextHelpFormatter)
-
-    parser.add_argument('-d', '--display', default=constants.DISPLAY_EXTERNAL,
-                        help='Display all interfaces or only external interfaces')
-    parser.add_argument('-n', '--namespace', default=None,
-                        help='Display interfaces for specific namespace')
-    return parser
-
-def multi_asic_get_ip_intf_from_ns(namespace):
-    if namespace != constants.DEFAULT_NAMESPACE:
-        pyroute2.netns.pushns(namespace)
-    interfaces = natsorted(netifaces.interfaces())
-
-    if namespace != constants.DEFAULT_NAMESPACE:
-        pyroute2.netns.popns()
-
-    return interfaces
-
-
-def multi_asic_get_ip_intf_addr_from_ns(namespace, iface):
-    if namespace != constants.DEFAULT_NAMESPACE:
-        pyroute2.netns.pushns(namespace)
-    ipaddresses = netifaces.ifaddresses(iface)
-
-    if namespace != constants.DEFAULT_NAMESPACE:
-        pyroute2.netns.popns()
-
-    return ipaddresses
diff --git a/utilities_common/netstat.py b/utilities_common/netstat.py
deleted file mode 100755
index 5f17c1f4..00000000
--- a/utilities_common/netstat.py
+++ /dev/null
@@ -1,120 +0,0 @@
-# network statistics utility functions #
-
-import json
-
-STATUS_NA = 'N/A'
-PORT_RATE = 40
-
-def ns_diff(newstr, oldstr):
-    """
-        Calculate the diff.
-    """
-    if newstr == STATUS_NA:
-        return STATUS_NA
-
-    # if new is valid but old is not we should return new
-    if oldstr == STATUS_NA:
-        oldstr = '0'
-
-    new, old = int(newstr), int(oldstr)
-    return '{:,}'.format(max(0, new - old))
-
-def ns_brate(newstr, oldstr, delta):
-    """
-        Calculate the byte rate.
-    """
-    if newstr == STATUS_NA or oldstr == STATUS_NA:
-        return STATUS_NA
-    else:
-        rate = int(ns_diff(newstr, oldstr).replace(',',''))/delta
-        if rate > 1000*1000*10:
-            rate = "{:.2f}".format(rate/1000/1000)+' MB'
-        elif rate > 1000*10:
-            rate = "{:.2f}".format(rate/1000)+' KB'
-        else:
-            rate = "{:.2f}".format(rate)+' B'
-        return rate+'/s'
-
-def ns_prate(newstr, oldstr, delta):
-    """
-        Calculate the packet rate.
-    """
-    if newstr == STATUS_NA or oldstr == STATUS_NA:
-        return STATUS_NA
-    else:
-        rate = int(ns_diff(newstr, oldstr).replace(',',''))/delta
-        return "{:.2f}".format(rate)+'/s'
-
-def ns_util(newstr, oldstr, delta, port_rate=PORT_RATE):
-    """
-        Calculate the util.
-    """
-    if newstr == STATUS_NA or oldstr == STATUS_NA:
-        return STATUS_NA
-    else:
-        rate = int(ns_diff(newstr, oldstr).replace(',',''))/delta
-        util = rate/(port_rate*1000*1000*1000/8.0)*100
-        return "{:.2f}%".format(util)
-
-def table_as_json(table, header):
-    """
-        Print table as json format.
-    """
-    output = {}
-
-    # Build a dictionary where the if_name is the key and the value is
-    # a dictionary that holds MTU, TX_DRP, etc
-    for line in table:
-        if_name = line[0]
-        output[if_name] = {header[i]: line[i] for i in range(1, len(header))}
-    
-    return json.dumps(output, indent=4, sort_keys=True)
-
-
-def format_number_with_comma(number_in_str):
-    """
-        Format the number with comma.
-    """
-    if number_in_str.isdecimal():
-        return '{:,}'.format(int(number_in_str))
-    else:
-        return number_in_str
-
-
-def format_brate(rate):
-    """
-    Show the byte rate.
-    """
-    if rate == STATUS_NA:
-        return STATUS_NA
-    else:
-        rate = float(rate)
-        if rate > 1000*1000*10:
-            rate = "{:.2f}".format(rate/1000/1000.0)+' MB'
-        elif rate > 1000*10:
-            rate = "{:.2f}".format(rate/1000.0)+' KB'
-        else:
-            rate = "{:.2f}".format(rate)+' B'
-        return rate+'/s'
-
-
-def format_prate(rate):
-    """
-    Show the packet rate.
-    """
-    if rate == STATUS_NA:
-        return STATUS_NA
-    else:
-        return "{:.2f}".format(float(rate))+'/s'
-
-
-def format_util(brate, port_rate):
-    """
-        Calculate the util.
-    """
-    if brate == STATUS_NA or port_rate == STATUS_NA:
-        return STATUS_NA
-    else:
-        util = brate/(float(port_rate)*1000*1000/8.0)*100
-        return "{:.2f}%".format(util)
-
diff --git a/utilities_common/platform_sfputil_helper.py b/utilities_common/platform_sfputil_helper.py
deleted file mode 100644
index 0de83f05..00000000
--- a/utilities_common/platform_sfputil_helper.py
+++ /dev/null
@@ -1,147 +0,0 @@
-import sys
-
-import click
-
-from . import cli as clicommon
-from sonic_py_common import multi_asic, device_info
-
-platform_sfputil = None
-platform_chassis = None
-platform_sfp_base = None
-platform_porttab_mapping_read = False
-
-RJ45_PORT_TYPE = 'RJ45'
-
-def load_platform_sfputil():
-
-    global platform_sfputil
-    try:
-        import sonic_platform_base.sonic_sfp.sfputilhelper
-        platform_sfputil = sonic_platform_base.sonic_sfp.sfputilhelper.SfpUtilHelper()
-    except Exception as e:
-        click.echo("Failed to instantiate platform_sfputil due to {}".format(repr(e)))
-        sys.exit(1)
-
-    return 0
-
-
-def platform_sfputil_read_porttab_mappings():
-    global platform_porttab_mapping_read
-
-    if platform_porttab_mapping_read:
-        return 0
-
-    try:
-
-        if multi_asic.is_multi_asic():
-            # For multi ASIC platforms we pass DIR of port_config_file_path and the number of asics
-            (platform_path, hwsku_path) = device_info.get_paths_to_platform_and_hwsku_dirs()
-
-            # Load platform module from source
-            platform_sfputil.read_all_porttab_mappings(hwsku_path, multi_asic.get_num_asics())
-        else:
-            # For single ASIC platforms we pass port_config_file_path and the asic_inst as 0
-            port_config_file_path = device_info.get_path_to_port_config_file()
-            platform_sfputil.read_porttab_mappings(port_config_file_path, 0)
-
-        platform_porttab_mapping_read = True
-    except Exception as e:
-        click.echo("Error reading port info (%s)" % str(e))
-        sys.exit(1)
-
-    return 0
-
-
-def logical_port_name_to_physical_port_list(port_name):
-    try:
-        if port_name.startswith("Ethernet"):
-            if platform_sfputil.is_logical_port(port_name):
-                return platform_sfputil.get_logical_to_physical(port_name)
-        else:
-            return [int(port_name)]
-    except ValueError:
-        pass
-
-    click.echo("Invalid port '{}'".format(port_name))
-    return None
-
-
-def get_logical_list():
-
-    return platform_sfputil.logical
-
-
-def get_asic_id_for_logical_port(port):
-
-    return platform_sfputil.get_asic_id_for_logical_port(port)
-
-
-def get_physical_to_logical():
-
-    return platform_sfputil.physical_to_logical
-
-
-def get_interface_name(port, db):
-
-    if port != "all" and port is not None:
-        alias = port
-        iface_alias_converter = clicommon.InterfaceAliasConverter(db)
-        if clicommon.get_interface_naming_mode() == "alias":
-            port = iface_alias_converter.alias_to_name(alias)
-            if port is None:
-                click.echo("cannot find port name for alias {}".format(alias))
-                sys.exit(1)
-
-    return port
-
-def get_interface_alias(port, db):
-
-    if port != "all" and port is not None:
-        alias = port
-        iface_alias_converter = clicommon.InterfaceAliasConverter(db)
-        if clicommon.get_interface_naming_mode() == "alias":
-            port = iface_alias_converter.name_to_alias(alias)
-            if port is None:
-                click.echo("cannot find port name for alias {}".format(alias))
-                sys.exit(1)
-
-    return port
-
-
-def is_rj45_port(port_name):
-    global platform_sfputil
-    global platform_chassis
-    global platform_sfp_base
-    global platform_sfputil_loaded
-
-    try:
-        if not platform_chassis:
-            import sonic_platform
-            platform_chassis = sonic_platform.platform.Platform().get_chassis()
-        if not platform_sfp_base:
-            import sonic_platform_base
-            platform_sfp_base = sonic_platform_base.sfp_base.SfpBase
-    except ModuleNotFoundError as e:
-        # This method is referenced by intfutil which is called on vs image
-        # However, there is no platform API supported on vs image
-        # So False is returned in such case
-        return False
-
-    if platform_chassis and platform_sfp_base:
-        if not platform_sfputil:
-            load_platform_sfputil()
-
-        if not platform_porttab_mapping_read:
-            platform_sfputil_read_porttab_mappings()
-
-        port_type = None
-        try:
-            physical_port = platform_sfputil.get_logical_to_physical(port_name)
-            if physical_port:
-                port_type = platform_chassis.get_port_or_cage_type(physical_port[0])
-        except Exception as e:
-            pass
-
-        return port_type == platform_sfp_base.SFP_PORT_TYPE_BIT_RJ45
-
-    return False
diff --git a/utilities_common/util_base.py b/utilities_common/util_base.py
deleted file mode 100644
index 98fc2306..00000000
--- a/utilities_common/util_base.py
+++ /dev/null
@@ -1,91 +0,0 @@
-import os
-import pkgutil
-import importlib
-
-from sonic_py_common import logger
-
-# Constants ====================================================================
-PDDF_SUPPORT_FILE = '/usr/share/sonic/platform/pddf_support'
-
-# Helper classs
-
-log = logger.Logger()
-
-
-class UtilHelper(object):
-    def __init__(self):
-        pass
-
-    def load_plugins(self, plugins_namespace):
-        """ Discover and load CLI plugins. Yield a plugin module. """
-
-        def iter_namespace(ns_pkg):
-            return pkgutil.iter_modules(ns_pkg.__path__, ns_pkg.__name__ + ".")
-
-        for _, module_name, ispkg in iter_namespace(plugins_namespace):
-            if ispkg:
-                yield from self.load_plugins(importlib.import_module(module_name))
-                continue
-            log.log_debug('importing plugin: {}'.format(module_name))
-            try:
-                module = importlib.import_module(module_name)
-            except Exception as err:
-                log.log_error('failed to import plugin {}: {}'.format(module_name, err),
-                              also_print_to_console=True)
-                continue
-
-            yield module
-
-    def register_plugin(self, plugin, root_command):
-        """ Register plugin in top-level command root_command. """
-
-        name = plugin.__name__
-        log.log_debug('registering plugin: {}'.format(name))
-        try:
-            plugin.register(root_command)
-        except Exception as err:
-            log.log_error('failed to import plugin {}: {}'.format(name, err),
-                          also_print_to_console=True)
-
-    # try get information from platform API and return a default value if caught NotImplementedError
-    def try_get(self, callback, default=None):
-        """
-        Handy function to invoke the callback, catch NotImplementedError and return a default value
-        :param callback: Callback to be invoked
-        :param default: Default return value if exception occur
-        :return: Default return value if exception occur else return value of the callback
-        """
-        try:
-            ret = callback()
-            if ret is None:
-                ret = default
-        except NotImplementedError:
-            ret = default
-
-        return ret
-
-    # Instantiate platform-specific Chassis class
-    def load_platform_chassis(self):
-        chassis = None
-
-        # Load 2.0 platform API chassis class
-        try:
-            import sonic_platform
-            chassis = sonic_platform.platform.Platform().get_chassis()
-        except Exception as e:
-            raise Exception("Failed to load chassis due to {}".format(repr(e)))
-
-        return chassis
-
-    # Check for PDDF mode enabled
-    def check_pddf_mode(self):
-        if os.path.exists(PDDF_SUPPORT_FILE):
-            return True
-        else:
-            return False
-
-    def load_and_register_plugins(self, plugins, cli):
-        """ Load plugins and register them """
-
-        for plugin in self.load_plugins(plugins):
-            self.register_plugin(plugin, cli)
\ No newline at end of file
-- 
2.25.1

