From c1671703e262eedf3e69a045237306abd8ef2400 Mon Sep 17 00:00:00 2001
From: jarvis_wc_chen <jarvis_wc_chen@wistron.com>
Date: Wed, 27 Jul 2022 08:27:59 +0000
Subject: [PATCH] Set MAC into eeprom

---
 transporthandler.cpp | 58 ++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 56 insertions(+), 2 deletions(-)

diff --git a/transporthandler.cpp b/transporthandler.cpp
index b2b7dce..9f5fd4d 100644
--- a/transporthandler.cpp
+++ b/transporthandler.cpp
@@ -10,6 +10,8 @@ using sdbusplus::xyz::openbmc_project::Network::server::EthernetInterface;
 using sdbusplus::xyz::openbmc_project::Network::server::IP;
 using sdbusplus::xyz::openbmc_project::Network::server::Neighbor;
 
+#define BMC_PATH "/sys/bus/i2c/device/8-0051/eeprom"
+
 namespace cipher
 {
 
@@ -305,6 +307,31 @@ void setMACProperty(sdbusplus::bus::bus& bus, const ChannelParams& params,
                     macStr);
 }
 
+/** @brief Sets the system value for MAC volatile attribute.
+ *
+ *  @param[in] bus        - The bus object used for lookups
+ *  @param[in] params     - The parameters for the channel
+ */
+bool getMACVolatileProperty(sdbusplus::bus::bus& bus, const ChannelParams& params)
+{
+    auto macNonVolatile = std::get<bool>(getDbusProperty(
+        bus, params.service, params.ifPath, INTF_MAC, "MacNonVolatile"));
+    return macNonVolatile;
+}
+
+/** @brief Sets the system value for MAC volatile attribute.
+ *
+ *  @param[in] bus        - The bus object used for lookups
+ *  @param[in] params     - The parameters for the channel
+ *  @param[in] isnonvolatile - MAC volatile attribute.
+ */
+void setMACVolatileProperty(sdbusplus::bus::bus& bus, const ChannelParams& params,
+                    const bool isnonvolatile)
+{
+    setDbusProperty(bus, params.service, params.ifPath, INTF_MAC, "MacNonVolatile",
+                    isnonvolatile);
+}
+
 void deleteObjectIfExists(sdbusplus::bus::bus& bus, const std::string& service,
                           const std::string& path)
 {
@@ -805,7 +832,13 @@ RspType<message::Payload> getLanOem(uint8_t channel, uint8_t parameter,
 RspType<> setLanOem(uint8_t channel, uint8_t parameter, message::Payload& req)
 {
     req.trailingOk = true;
-    return response(ccParamNotSupported);
+    if (parameter == 0xc1) {
+        channelCall<setMACVolatileProperty>(channel, 0);
+    }
+    if (parameter == 0xc2) {
+        channelCall<setMACVolatileProperty>(channel, 1);
+    }
+    return responseSuccess();
 }
 
 RspType<message::Payload> getLanOem(uint8_t channel, uint8_t parameter,
@@ -838,6 +871,21 @@ bool isValidMACAddress(const ether_addr& mac)
     return true;
 }
 
+int writeMacToEeprom(ether_addr mac)
+{
+    auto fp = open(BMC_PATH, O_RDWR);
+    ssize_t writtenBytes = write(fp, mac.ether_addr_octet, sizeof(mac.ether_addr_octet));
+    if (writtenBytes < 0)
+    {
+        log<level::ERR>("writeMacToEeprom: unable to write to i2c device");
+        close(fp);
+        return -1;
+    }
+
+    close(fp);
+    return 0;
+}
+
 RspType<> setLan(Context::ptr ctx, uint4_t channelBits, uint4_t reserved1,
                  uint8_t parameter, message::Payload& req)
 {
@@ -968,11 +1016,17 @@ RspType<> setLan(Context::ptr ctx, uint4_t channelBits, uint4_t reserved1,
                 return responseReqDataLenInvalid();
             }
             copyInto(mac, bytes);
-
             if (!isValidMACAddress(mac))
             {
                 return responseInvalidFieldRequest();
             }
+            auto isNonVolatile = channelCall<getMACVolatileProperty>(channel);
+            if (isNonVolatile) {
+                auto ret = writeMacToEeprom(mac);
+                if (ret)
+                    return responseUnspecifiedError();
+            }
+
             channelCall<setMACProperty>(channel, mac);
             return responseSuccess();
         }
-- 
2.25.1

